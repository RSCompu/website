<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Monitoring System</title>
    <style>
        :root {
            --neon-cyan: #00f3ff;
            --neon-magenta: #bc13fe;
            --neon-purple: #8a2be2;
            --neon-red: #ff0055;
            --neon-amber: #ffbf00;
            --neon-blue: #0066ff;
            --neon-dark-blue: #002266;
            --neon-green: #00a800;
            --bg-color: #050505;
            --glass-bg: rgba(5, 20, 5, 0.75);
            --glass-border: rgba(0, 168, 0, 0.3);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--neon-green);
            height: 100vh;
            width: 100vw;
        }

        /* Canvas container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Vignette and scanlines overlay */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            background: radial-gradient(circle, transparent 50%, black 150%);
            pointer-events: none;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0.3;
        }

        /* Control Panel */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 20px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
            transition: transform 0.3s ease;
        }

        #controls.collapsed {
            transform: translateX(calc(100% + 40px));
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .control-header h3 {
            margin: 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--neon-magenta);
            text-shadow: 0 0 5px var(--neon-magenta);
        }

        .toggle-btn {
            background: transparent;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            cursor: pointer;
            padding: 2px 8px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 2px var(--neon-cyan);
        }

        .slider-container {
            display: flex;
            align-items: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--neon-green);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .value-display {
            width: 40px;
            text-align: right;
            font-size: 12px;
            color: var(--neon-green);
            margin-left: 10px;
        }

        /* Status Toggles */
        .switches {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .switch-btn {
            flex: 1;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #444;
            color: #888;
            cursor: pointer;
            font-size: 10px;
            text-transform: uppercase;
            transition: all 0.3s;
            text-align: center;
        }

        .switch-btn.active {
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 10px rgba(0, 168, 0, 0.2);
        }

        .switch-btn.active.alert {
            border-color: var(--neon-red);
            color: var(--neon-red);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3);
        }

        /* Stats display top left */
        #hud-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 5;
            pointer-events: none;
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.7);
            margin-right: 10px;
        }

        .stat-val {
            color: var(--neon-green);
            font-weight: bold;
        }

        .blinking {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* --- NEW SIDE MONITOR STYLES --- */
        #side-monitor {
            position: absolute;
            top: 25%;
            left: 20px;
            width: 250px;
            height: 150px;
            /* Dark Blue Border (~5mm visual equivalent) */
            border: 5px solid var(--neon-dark-blue); 
            background: rgba(0, 5, 20, 0.85);
            z-index: 8;
            box-shadow: 0 0 15px var(--neon-dark-blue), inset 0 0 20px rgba(0, 34, 102, 0.5);
            border-radius: 4px;
            
            /* Opening Animation */
            transform: scaleX(0);
            transform-origin: left;
            animation: openMonitor 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 1s forwards;
            overflow: hidden;
            pointer-events: auto; /* CHANGED: Enabled pointer events for dragging */
        }

        #side-monitor h4 {
            margin: 0;
            padding: 5px 10px;
            background: var(--neon-dark-blue);
            color: #fff;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: move; /* ADDED: Cursor to indicate draggable */
            user-select: none; /* ADDED: Prevent text selection while dragging */
        }

        #waveCanvas {
            width: 100%;
            height: calc(100% - 25px);
            display: block;
        }

        @keyframes openMonitor {
            from { transform: scaleX(0); opacity: 0; }
            to { transform: scaleX(1); opacity: 1; }
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #controls {
                width: calc(100% - 40px);
                bottom: 10px;
                right: 20px;
                left: 20px;
            }
            #side-monitor {
                display: none; /* Hide side monitor on small mobile screens to save space */
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="cyberCanvas"></canvas>
    </div>

    <!-- NEW SIDE MONITOR -->
    <div id="side-monitor">
        <h4>AUX_WAVEFORM_V2</h4>
        <canvas id="waveCanvas"></canvas>
    </div>

    <div class="overlay"></div>
    <div class="scanlines"></div>

    <div id="hud-stats">
        <div class="stat-row">
            <span class="stat-label">SYSTEM:</span>
            <span class="stat-val">ONLINE</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">NET:</span>
            <span class="stat-val">SECURE</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">TARGETS:</span>
            <span class="stat-val" id="target-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">THREAT:</span>
            <span class="stat-val blinking" id="threat-level" style="color: var(--neon-green);">LOW</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">FPS:</span>
            <span class="stat-val" id="fps-counter">60</span>
        </div>
    </div>

    <div id="controls">
        <div class="control-header">
            <h3>SYS_CONFIG</h3>
            <button class="toggle-btn" id="minimize-btn">_</button>
        </div>

        <div class="control-group">
            <label>ROTATION SPEED</label>
            <div class="slider-container">
                <input type="range" id="speed-slider" min="0" max="200" value="50">
                <span class="value-display" id="speed-val">50%</span>
            </div>
        </div>

        <div class="control-group">
            <label>RADAR SWEEP</label>
            <div class="slider-container">
                <input type="range" id="radar-slider" min="0" max="100" value="60">
                <span class="value-display" id="radar-val">60%</span>
            </div>
        </div>

        <div class="control-group">
            <label>DATA DENSITY</label>
            <div class="slider-container">
                <input type="range" id="data-slider" min="0" max="100" value="40">
                <span class="value-display" id="data-val">40%</span>
            </div>
        </div>

        <div class="control-group">
            <label>NEON GLOW</label>
            <div class="slider-container">
                <input type="range" id="glow-slider" min="0" max="50" value="20">
                <span class="value-display" id="glow-val">20</span>
            </div>
        </div>

        <div class="switches">
            <div class="switch-btn active" id="markers-btn">MARKERS</div>
            <div class="switch-btn" id="alert-btn">ALERT</div>
            <div class="switch-btn active" id="text-btn">DATA</div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION & STATE ---
        const canvas = document.getElementById('cyberCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height, centerX, centerY;
        let frames = 0;
        let lastTime = 0;
        
        const state = {
            rotationSpeed: 0.5,
            radarSpeed: 0.03,
            dataDensity: 0.4,
            glowIntensity: 20,
            showMarkers: true,
            alertMode: false,
            showText: true
        };

        const colors = {
            cyan: '#00f3ff',
            magenta: '#bc13fe',
            purple: '#8a2be2',
            blue: '#0066ff',
            red: '#ff0055',
            amber: '#ffbf00',
            green: '#00a800',
            darkBlue: '#002266', // Added dark blue
            dark: '#0a0f14'
        };

        // --- ENTITIES ---

        // 1. Rings (The circular HUD elements)
        class Ring {
            constructor(radius, speed, width, color, type) {
                this.radius = radius;
                this.baseSpeed = speed;
                this.speed = speed;
                this.width = width;
                this.color = color;
                this.type = type; // 'solid', 'dashed', 'segmented', 'ticks'
                this.angle = Math.random() * Math.PI * 2;
                this.dashLen = Math.random() * 0.5 + 0.1;
            }

            update() {
                this.angle += this.baseSpeed * state.rotationSpeed * 0.02;
            }

            draw() {
                ctx.beginPath();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width;
                ctx.shadowBlur = state.glowIntensity;
                ctx.shadowColor = this.color;

                if (state.alertMode && (this.color === colors.cyan || this.color === colors.blue)) {
                    ctx.shadowColor = colors.red;
                    ctx.strokeStyle = colors.red;
                }

                if (this.type === 'solid') {
                    ctx.arc(centerX, centerY, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } 
                else if (this.type === 'dashed') {
                    ctx.setLineDash([10, 20]);
                    ctx.arc(centerX, centerY, this.radius, this.angle, this.angle + Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                else if (this.type === 'segmented') {
                    const segments = 6;
                    const gap = 0.2;
                    const segLen = (Math.PI * 2) / segments - gap;
                    
                    for(let i=0; i<segments; i++) {
                        let start = this.angle + i * (segLen + gap);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.radius, start, start + segLen);
                        ctx.stroke();
                    }
                }
                else if (this.type === 'ticks') {
                    const ticks = 40;
                    for(let i=0; i<ticks; i++) {
                        const a = this.angle + (i / ticks) * Math.PI * 2;
                        const x1 = centerX + Math.cos(a) * this.radius;
                        const y1 = centerY + Math.sin(a) * this.radius;
                        const x2 = centerX + Math.cos(a) * (this.radius + 10);
                        const y2 = centerY + Math.sin(a) * (this.radius + 10);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
        }

        // 2. Map Points / Crime Markers
        class Marker {
            constructor() {
                this.reset();
            }

            reset() {
                const angle = Math.random() * Math.PI * 2;
                // Place within the inner circles
                const dist = Math.random() * (Math.min(width, height) * 0.25); 
                this.x = centerX + Math.cos(angle) * dist;
                this.y = centerY + Math.sin(angle) * dist;
                this.life = 0;
                this.maxLife = 100 + Math.random() * 100;
                this.type = Math.random() > 0.7 ? 'crime' : (Math.random() > 0.5 ? 'police' : 'event');
                this.active = true;
            }

            update() {
                if(!state.showMarkers) return;
                this.life++;
                if (this.life > this.maxLife) {
                    this.reset();
                }
            }

            draw() {
                if(!state.showMarkers) return;
                
                let color = colors.amber;
                let size = 3;
                
                if (this.type === 'crime') {
                    color = colors.red;
                    size = 4;
                } else if (this.type === 'police') {
                    color = colors.blue;
                }

                // Blink effect
                const opacity = Math.abs(Math.sin(this.life * 0.05));
                
                ctx.globalAlpha = opacity;
                ctx.fillStyle = color;
                ctx.shadowBlur = state.glowIntensity / 2;
                ctx.shadowColor = color;
                
                // Draw dot
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Draw expanding ring occasionally
                if (this.life % 40 < 20) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.arc(this.x, this.y, size + (this.life % 20), 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw label line
                if (this.type === 'crime' && this.life < 50) {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + 15, this.y - 15);
                    ctx.lineTo(this.x + 35, this.y - 15);
                    ctx.stroke();
                    
                    ctx.font = '8px Arial';
                    ctx.fillStyle = color;
                    ctx.fillText('DETECT', this.x + 18, this.y - 18);
                }

                ctx.globalAlpha = 1;
            }
        }

        // 3. Data Streams (Falling text/particles)
        class DataStream {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.speed = Math.random() * 2 + 1;
                this.chars = "01XYZ789ABCDEF".split('');
                this.text = "";
                this.updateText();
                this.opacity = Math.random() * 0.5 + 0.1;
                this.color = Math.random() > 0.8 ? colors.magenta : colors.green;
            }

            updateText() {
                let len = Math.floor(Math.random() * 5) + 3;
                this.text = "";
                for(let i=0; i<len; i++) {
                    this.text += this.chars[Math.floor(Math.random() * this.chars.length)];
                }
            }

            update() {
                this.y += this.speed * (state.rotationSpeed + 0.5); // Affected by system speed
                if (this.y > height) this.y = -50;
                
                if (Math.random() < 0.05) this.updateText();
            }

            draw() {
                if (!state.showText) return;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity * state.dataDensity; // Opacity controlled by density
                ctx.font = '10px monospace';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        // --- SIDE MONITOR WAVEFORM ---
        let waveCtx, waveWidth, waveHeight;
        function initWaveform() {
            const waveCanvas = document.getElementById('waveCanvas');
            waveCtx = waveCanvas.getContext('2d');
            
            const rect = waveCanvas.getBoundingClientRect();
            waveCanvas.width = rect.width;
            waveCanvas.height = rect.height;
            waveWidth = rect.width;
            waveHeight = rect.height;
        }

        function drawWaveform(time) {
            if(!waveCtx) return;
            
            // Clear side monitor canvas (fade effect)
            waveCtx.fillStyle = 'rgba(0, 5, 20, 0.2)';
            waveCtx.fillRect(0, 0, waveWidth, waveHeight);
            
            waveCtx.beginPath();
            waveCtx.strokeStyle = colors.blue;
            waveCtx.lineWidth = 2;
            waveCtx.shadowBlur = 5;
            waveCtx.shadowColor = colors.blue;

            const freq = 0.05;
            const amp = 30;
            const speed = time * 0.1;

            for(let x = 0; x < waveWidth; x+=2) {
                // Complex wave math
                const y = waveHeight/2 + 
                          Math.sin(x * freq + speed) * amp + 
                          Math.sin(x * 0.02 - speed * 1.5) * (amp/2);
                
                if(x===0) waveCtx.moveTo(x, y);
                else waveCtx.lineTo(x, y);
            }
            waveCtx.stroke();
        }

        // --- INIT & MAIN LOOP ---

        const rings = [];
        const markers = [];
        const streams = [];
        let radarAngle = 0;

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Create Rings
            // Ring(radius, speed, width, color, type)
            const minDim = Math.min(width, height);
            
            // Inner core
            rings.push(new Ring(minDim * 0.08, 0.5, 2, colors.green, 'solid'));
            rings.push(new Ring(minDim * 0.12, -0.3, 1, colors.green, 'segmented'));
            
            // Mid section
            rings.push(new Ring(minDim * 0.18, 0.2, 4, colors.green, 'dashed'));
            rings.push(new Ring(minDim * 0.20, -0.4, 1, colors.cyan, 'ticks')); // Kept one accent
            rings.push(new Ring(minDim * 0.25, 0.1, 1, colors.green, 'solid'));
            
            // Outer section
            rings.push(new Ring(minDim * 0.32, -0.1, 8, 'rgba(0, 168, 0, 0.1)', 'solid')); // Glass ring dark green
            rings.push(new Ring(minDim * 0.33, -0.2, 2, colors.green, 'dashed'));
            rings.push(new Ring(minDim * 0.40, 0.05, 1, colors.green, 'segmented'));

            // Create Markers
            for(let i=0; i<15; i++) {
                markers.push(new Marker());
            }

            // Create Data Streams
            for(let i=0; i<50; i++) {
                streams.push(new DataStream());
            }

            // Setup Controls
            setupEventListeners();
            
            // Init Waveform Monitor
            setTimeout(initWaveform, 100); // Wait for layout

            // Setup Dragging for Monitor
            setupMonitorDrag();

            requestAnimationFrame(animate);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            
            // Re-init waveform on resize
            initWaveform();
        }

        function setupMonitorDrag() {
            const monitor = document.getElementById('side-monitor');
            const header = monitor.querySelector('h4');
            
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            header.addEventListener("mousedown", dragStart);
            document.addEventListener("mouseup", dragEnd);
            document.addEventListener("mousemove", drag);

            function dragStart(e) {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                // If element hasn't been moved yet, calculate offset from computed style
                if (xOffset === 0 && yOffset === 0) {
                    const rect = monitor.getBoundingClientRect();
                    // We need to account for the initial top/left css
                    // But easier method for simple absolute positioning:
                    // Just rely on the rect relative to mouse
                }
                
                // Better simple drag approach for absolute elements:
                const rect = monitor.getBoundingClientRect();
                xOffset = e.clientX - rect.left;
                yOffset = e.clientY - rect.top;

                isDragging = true;
                monitor.style.transform = "none"; // Remove scale animation transform to prevent conflicts
                monitor.style.animation = "none";
                monitor.style.opacity = "1";
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    
                    currentX = e.clientX - xOffset;
                    currentY = e.clientY - yOffset;

                    // Boundary checks (optional, keeps it on screen)
                    if(currentX < 0) currentX = 0;
                    if(currentY < 0) currentY = 0;
                    if(currentX + monitor.offsetWidth > window.innerWidth) currentX = window.innerWidth - monitor.offsetWidth;
                    if(currentY + monitor.offsetHeight > window.innerHeight) currentY = window.innerHeight - monitor.offsetHeight;

                    monitor.style.left = currentX + "px";
                    monitor.style.top = currentY + "px";
                }
            }
        }

        function setupEventListeners() {
            // Speed Slider
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                state.rotationSpeed = e.target.value / 100;
                document.getElementById('speed-val').textContent = e.target.value + '%';
            });

            // Radar Slider
            document.getElementById('radar-slider').addEventListener('input', (e) => {
                state.radarSpeed = e.target.value / 2000;
                document.getElementById('radar-val').textContent = e.target.value + '%';
            });

            // Data Slider
            document.getElementById('data-slider').addEventListener('input', (e) => {
                state.dataDensity = e.target.value / 100;
                document.getElementById('data-val').textContent = e.target.value + '%';
            });

            // Glow Slider
            document.getElementById('glow-slider').addEventListener('input', (e) => {
                state.glowIntensity = parseInt(e.target.value);
                document.getElementById('glow-val').textContent = e.target.value;
            });

            // Toggles
            const markersBtn = document.getElementById('markers-btn');
            markersBtn.addEventListener('click', () => {
                state.showMarkers = !state.showMarkers;
                markersBtn.classList.toggle('active');
            });

            const alertBtn = document.getElementById('alert-btn');
            alertBtn.addEventListener('click', () => {
                state.alertMode = !state.alertMode;
                alertBtn.classList.toggle('active');
                alertBtn.classList.toggle('alert');
                
                const threatEl = document.getElementById('threat-level');
                if(state.alertMode) {
                    threatEl.textContent = "CRITICAL";
                    threatEl.style.color = colors.red;
                } else {
                    threatEl.textContent = "LOW";
                    threatEl.style.color = colors.green;
                }
            });

            const textBtn = document.getElementById('text-btn');
            textBtn.addEventListener('click', () => {
                state.showText = !state.showText;
                textBtn.classList.toggle('active');
            });

            // Minimize
            const controls = document.getElementById('controls');
            const minBtn = document.getElementById('minimize-btn');
            minBtn.addEventListener('click', () => {
                controls.classList.toggle('collapsed');
            });
        }

        function drawGrid() {
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Perspective transform effect for floor grid
            // Note: Canvas 2D doesn't support true 3D matrices easily, 
            // so we'll do a simple polar grid to simulate a floor or map
            
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Radial lines
            for(let i=0; i<12; i++) {
                ctx.beginPath();
                ctx.moveTo(0,0);
                const a = (i/12) * Math.PI * 2 + (frames * 0.001 * state.rotationSpeed);
                ctx.lineTo(Math.cos(a)*height, Math.sin(a)*height);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawRadar() {
            const radius = Math.min(width, height) * 0.35;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(radarAngle);
            
            // Radar Sweep Gradient
            const grad = ctx.createConicGradient(0, 0, 0);
            const sweepColor = state.alertMode ? colors.red : colors.cyan;
            
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.8, 'rgba(0,0,0,0)');
            grad.addColorStop(1, sweepColor); // End with solid color
            
            ctx.fillStyle = grad;
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Leading edge line
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.lineTo(radius, 0);
            ctx.strokeStyle = sweepColor;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 10;
            ctx.shadowColor = sweepColor;
            ctx.stroke();

            ctx.restore();
        }

        function animate(timestamp) {
            // FPS Calc
            const delta = timestamp - lastTime;
            lastTime = timestamp;
            if (frames % 20 === 0) {
                document.getElementById('fps-counter').innerText = Math.round(1000/delta);
            }
            frames++;

            // Clear Main Canvas
            ctx.fillStyle = colors.dark;
            ctx.fillRect(0, 0, width, height);

            // Draw Side Monitor Wave
            drawWaveform(frames);

            // Background Data Streams
            streams.forEach(s => {
                s.update();
                s.draw();
            });

            // Grid Map
            drawGrid();

            // Rings
            rings.forEach(ring => {
                ring.update();
                ring.draw();
            });

            // Radar
            radarAngle += state.radarSpeed;
            drawRadar();

            // Markers
            let visibleMarkers = 0;
            markers.forEach(marker => {
                marker.update();
                marker.draw();
                if(marker.life < marker.maxLife) visibleMarkers++;
            });
            
            if (frames % 10 === 0) {
               document.getElementById('target-count').innerText = visibleMarkers;
            }

            // Central Crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - 10, centerY);
            ctx.lineTo(centerX + 10, centerY);
            ctx.moveTo(centerX, centerY - 10);
            ctx.lineTo(centerX, centerY + 10);
            ctx.stroke();

            // Vignette is handled by CSS overlay

            requestAnimationFrame(animate);
        }

        window.onload = init;

    </script>
</body>
</html>